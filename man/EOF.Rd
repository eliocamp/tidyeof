% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EOF.R
\name{EOF}
\alias{EOF}
\title{Empirical Orthogonal Function}
\usage{
EOF(formula, value.var = NULL, data = NULL, n = 1, B = 0,
  probs = c(lower = 0.025, mid = 0.5, upper = 0.975), rotate = FALSE,
  suffix = "PC", fill = 0)
}
\arguments{
\item{formula}{a formula passed to \code{\link[data.table]{dcast}} to build
the matrix that will be used in the SVD decomposition (see Details)}

\item{value.var}{optional name of the data column (see Details)}

\item{data}{a data.frame}

\item{n}{which singular values to return (if \code{NULL}, returns all)}

\item{B}{number of bootstrap samples used to estimate confidence intervals.
Ignored if <= 1.}

\item{probs}{the probabilities of the lower and upper values of estiamted
confidence intervals. If named, it's names will be used as column names.}

\item{rotate}{if \code{TRUE}, scores and loadings will be rotated using \link{varimax}}

\item{suffix}{character to name de principal components}

\item{fill}{value to infill implicit missing values or \code{NULL} if the
data is dense.}
}
\value{
\describe{
\item{left}{data.table with left singular vectors}
\item{right}{data.table with right singular vectors}
\item{sdev}{data.table with singular values, their explained variance,
and, optionally, cuantiles estimated via bootstrap}
}
}
\description{
Computes Singular Value Decomposition (also known as Principal Components
Analysis or Empirical Orthogonal Functions).
}
\details{
Singular values can be computed over matrices so \code{formula} denotes how
to build a matrix from the data. It is a formula of the form VAR ~ LEFT | RIGHT
(see \link[Formula:Formula]{Formula::Formula}) in which VAR is the variable whose values will
populate the matrix, and LEFT represent the variables used to make the rows
and RIGHT, the columns of the matrix.
Think it like "VAR \emph{as a function} of LEFT \emph{and} RIGHT".

Alternatively, if \code{value.var} is not \code{NULL}, it's possible to use the
(probably) more familiar \link[data.table:dcast]{data.table::dcast} formula interface. In that case,
\code{data} must be provided.

The result of VAR ~ LHS | RHS and VAR ~ RHS | LHS (ie, terms reversed)
is the same.

The variable combination used in this formula \emph{must} identify
an unique value in a cell. For the time being, no error will be raised, but
there will be a message from \code{\link[data.table]{dcast}}. If not every
combination is present in the data,

In the result, the left and right vectors have dimensions of the LEFT and RIGHT
part of the \code{formula}, respectively.

It is much faster to compute only some singular vectors, so is advisable not
to set n to \code{NULL}. If the irba package is installed, EOF uses
\link[irlba:irlba]{irlba::irlba} instead of \link[base:svd]{base::svd} since it's much faster.

The boostraping procedure follows Fisher et.al. (2016) and returns the
standard deviation of each singular value.
}
\examples{
library(dplyr)
library(ggplot2)
library(data.table)

arrests <- USArrests \%>\%
  mutate(state = rownames(USArrests)) \%>\%
  melt(id.vars = "state", variable.name = "crime", value.name = "rate") \%>\%
  group_by(crime) \%>\%
  mutate(rate_anomaly = (rate - mean(rate))/sd(rate))

arrests_eof <- EOF(rate_anomaly ~ crime | state, data = arrests, n = 1:4)

summary(arrests_eof)

autoplot(arrests_eof)

ggplot(arrests_eof$right, aes(PC, state)) +
  geom_raster(aes(fill = rate_anomaly))

cut(arrests_eof, 1:2) \%>\%
  .$left \%>\%
  dcast(crime ~ PC, value.var = "rate_anomaly") \%>\%
  ggplot(aes(PC1, PC2)) +
  geom_text(aes(label = crime))

# Alternative interface
arrests_eof <- EOF(crime ~ state, value.var = "rate_anomaly", data = arrests, n = 1:4)

}
\references{
Fisher, A., Caffo, B., Schwartz, B., & Zipunnikov, V. (2016). Fast, Exact Bootstrap Principal Component Analysis for p > 1 million. Journal of the American Statistical Association, 111(514), 846â€“860. http://doi.org/10.1080/01621459.2015.1062383
}
